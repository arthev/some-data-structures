(in-package :testing-some-data-structures)

;;;Utils
(defun knuth-shuffle (arr)
  (loop for i from (1- (length arr)) downto 1
        do (let ((j (random i)))
             (rotatef (aref arr i) (aref arr j))))
  arr)

(defmacro s (string &rest args)
  `(format nil ,string ,@args))

(defmacro hrepok (times str &body body)
  `(ok (dotimes (i ,times t)
         ,@body
         (unless (ds:verify-heap h) (return nil)))
       ,str))

;;;Tests
(plan nil)



(defun test-empty-p (heap-type)
  (let ((h (make-instance heap-type)))
    (ok (ds:empty-p h) (s "~A is empty upon creation." h))
    (ds:insert 1 1 h)
    (ok (not (ds:empty-p h)) (s "~A is not empty after an insert." h))
    (ds:pop-extrema h)
    (ok (ds:empty-p h) (s "~A is empty after pop after one insert." h))
    (dotimes (i 100)
      (ds:insert (random 100) (random 100) h))
    (ok (not (ds:empty-p h)) (s "~A is not empty after 100 inserts." h))
    (dotimes (i 100)
      (ds:pop-extrema h))
    (ok (ds:empty-p h) (s "~A is empty after popping the 100 inserts." h))))

(defun test-peek-extrema (heap-type)
  (let ((h (make-instance heap-type))
        (v (make-array 32 :fill-pointer 0 :adjustable t)))
    (dotimes (i 200)
      (let ((r (random 1000)))
        (ds:insert r r h)
        (vector-push-extend r v)))
    (sort v (ds:comp-fn h))
    (is (ds:key (ds:peek-extrema h)) (aref v 0)
        (s "~A's peek-extrema returns extrema." h))))

(defun test-insert (heap-type)
  (let ((h (make-instance heap-type)))
    (ok (ds:verify-heap h) (s "~A heap-verifies pre-insert." h))
    (hrepok 100 (s "~A heap-verifies ∀ 100 inserts." h)
      (let ((r (random 100)))
        (ds:insert r i h)))
    (is (ds:size h) 100 (s "~A has size 100 after 100 inserts." h))
    (hrepok 50 (s "~A heap-verifies ∀ 25 alt pop and updkey." h)
      (if (zerop (rem i 2))
          (ds:update-key (random 200) (ds:peek-extrema h) h)
          (ds:pop-extrema h)))
    (is (ds:size h) 75 (s "~A has size 75 after 100 inserts & 25 pops." h))
    (hrepok 40 (s "~A verifies ∀ 40 inserts after pops and upds." h)
      (let ((r (random 60)))
        (ds:insert r r h)))))

(defun test-pop-extrema (heap-type)
  (let ((h (make-instance heap-type))
        (v (make-array 32 :fill-pointer 0 :adjustable t)))
    (ok (null (ds:pop-extrema h))
        (s "~A returns nil when popped when empty." h))
    (dotimes (i 200)
      (let ((r (random 1000)))
        (ds:insert r r h)
        (vector-push-extend r v)))
    (sort v (complement (ds:comp-fn h)))
    (is (ds:key (ds:pop-extrema h)) (vector-pop v)
        (s "~A pops same key as least item in sorted vec." h))
    (ok (dotimes (i 199 t)
          (let ((hp (ds:key (ds:pop-extrema h)))
                (vp (vector-pop v)))
            (unless (and (eql hp vp) (ds:verify-heap h))
              (return nil))))
        (s "~A pops correct vals and heap-verifies ∀ pops." h))))

(defun test-delete-node (heap-type)
  (let ((h (make-instance heap-type))
        (ht (make-hash-table))
        (v (make-array 100)))
    (ds:insert 1 1 h)
    (ds:delete-node (ds:peek-extrema h) h)
    (ok (ds:empty-p h) (s "~A is empty after delete-node on root." h))

    (dotimes (i 100)
      (let ((r (random 100)))
        (setf (gethash i ht) (ds:insert r i h))
        (setf (aref v i) i)))
    (knuth-shuffle v)
    (dotimes (i 20)
      (ds:update-key (random 100) (gethash (random 100) ht) h))
    (ok (loop for n across v
              do (ds:delete-node (gethash n ht) h)
              when (not (ds:verify-heap h))
                do (return nil)
              finally (return t))
        (s "~A heap-verifies ∀ node deletions in random order." h))
    (ok (ds:empty-p h) (s "~A is empty after deleting all nodes." h))))

(defun test-update-key (heap-type)
  (let ((h (make-instance heap-type))
        (v (make-array 200 :fill-pointer 0 :adjustable t)))
    (dotimes (i 200)
      (let ((r (random 200)))
        (vector-push-extend (ds:insert r i h) v)))
    (hrepok 100 (s "~A heap-verifies ∀ 100 key updates." h)
      (ds:update-key (random 300) (aref v (random 200)) h))))

(defun test-meld (heap-type)
  (let ((h1 (make-instance heap-type))
        (h2 (make-instance heap-type)))
    (ok (ds:empty-p (ds:meld h1 h2))
        (s "~A meld w/ two empty heaps returns an empty one." heap-type)))

  (let ((h1 (make-instance heap-type))
        (h2 (make-instance heap-type)))
    (ds:insert 1 1 h1)
    (is (ds:meld h1 h2)
        h1
        (s "~A meld returns non-empty heap if given one 
                     empty heap." heap-type)))

  (let ((h1 (make-instance heap-type))
        (h2 (make-instance heap-type)))
    (let ((n1 (ds:insert 3 3 h1)))
      (ds:insert 5 5 h2)
      (ds:meld h1 h2)
      (ok (and (eql (ds:peek-extrema h1) (ds:peek-extrema h2))
               (eql (ds:peek-extrema h1) n1))
          (s "~A root of heaps meld updates to correct 
                       element given two 1-node heaps." heap-type))))
  
  (let ((h1 (make-instance heap-type))
        (h2 (make-instance heap-type)))
    (dotimes (i 40)
      (ds:insert (random 100) i h1))
    (dotimes (i 60)
      (ds:insert (random 100) i h2))
    (let ((n1 (ds:peek-extrema h1))
          (n2 (ds:peek-extrema h2)))
      (ds:meld h1 h2)
      (ok (and (ds:verify-heap h1) (ds:verify-heap h2))
          (s "~A verifies both heap args after a meld." heap-type))
      (ok (or (eql n1 (ds:peek-extrema h1))
              (eql n2 (ds:peek-extrema h1)))
          (s "~A post-meld has root as expected." heap-type))
      (is (ds:size h1)
          100
          (s "~A has size 100 after melding |60| and |40|." h1))))
  
  (let ((h1 (make-instance heap-type :comp-fn #'<))
        (h2 (make-instance heap-type :comp-fn #'>)))
    (ok (block error-block
          (handler-case (ds:meld h1 h2)
            (error ()
              (return-from error-block t)))
          nil)
        (s "~A meld generates error if heaps w/ diff comp-fns
                     are attempted melded." heap-type))))
  

(defun test-suite (heap-type)
  (assert (typep heap-type 'symbol)) ;Can be made more extensive.
  (test-empty-p heap-type)
  (test-peek-extrema heap-type)
  (test-insert heap-type)
  (test-pop-extrema heap-type)
  (test-delete-node heap-type)
  (test-update-key heap-type)
  (test-meld heap-type)
  )

(test-suite 'ds:pairing-heap)
(test-suite 'ds:binary-heap)



(finalize)
